{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketServer = void 0;\n\nconst events_1 = __importDefault(require(\"events\"));\n\nconst url_1 = __importDefault(require(\"url\"));\n\nconst ws_1 = __importDefault(require(\"ws\"));\n\nconst enums_1 = require(\"../../enums\");\n\nconst client_1 = require(\"../../models/client\");\n\nconst WS_PATH = 'peerjs';\n\nclass WebSocketServer extends events_1.default {\n  constructor({\n    server,\n    realm,\n    config\n  }) {\n    super();\n    this.setMaxListeners(0);\n    this.realm = realm;\n    this.config = config;\n    const path = this.config.path;\n    this.path = `${path}${path.endsWith('/') ? \"\" : \"/\"}${WS_PATH}`;\n    this.socketServer = new ws_1.default.Server({\n      path: this.path,\n      server\n    });\n    this.socketServer.on(\"connection\", (socket, req) => this._onSocketConnection(socket, req));\n    this.socketServer.on(\"error\", error => this._onSocketError(error));\n  }\n\n  _onSocketConnection(socket, req) {\n    var _a;\n\n    const {\n      query = {}\n    } = url_1.default.parse((_a = req.url) !== null && _a !== void 0 ? _a : '', true);\n    const {\n      id,\n      token,\n      key\n    } = query;\n\n    if (!id || !token || !key) {\n      return this._sendErrorAndClose(socket, enums_1.Errors.INVALID_WS_PARAMETERS);\n    }\n\n    if (key !== this.config.key) {\n      return this._sendErrorAndClose(socket, enums_1.Errors.INVALID_KEY);\n    }\n\n    const client = this.realm.getClientById(id);\n\n    if (client) {\n      if (token !== client.getToken()) {\n        // ID-taken, invalid token\n        socket.send(JSON.stringify({\n          type: enums_1.MessageType.ID_TAKEN,\n          payload: {\n            msg: \"ID is taken\"\n          }\n        }));\n        return socket.close();\n      }\n\n      return this._configureWS(socket, client);\n    }\n\n    this._registerClient({\n      socket,\n      id,\n      token\n    });\n  }\n\n  _onSocketError(error) {\n    // handle error\n    this.emit(\"error\", error);\n  }\n\n  _registerClient({\n    socket,\n    id,\n    token\n  }) {\n    // Check concurrent limit\n    const clientsCount = this.realm.getClientsIds().length;\n\n    if (clientsCount >= this.config.concurrent_limit) {\n      return this._sendErrorAndClose(socket, enums_1.Errors.CONNECTION_LIMIT_EXCEED);\n    }\n\n    const newClient = new client_1.Client({\n      id,\n      token\n    });\n    this.realm.setClient(newClient, id);\n    socket.send(JSON.stringify({\n      type: enums_1.MessageType.OPEN\n    }));\n\n    this._configureWS(socket, newClient);\n  }\n\n  _configureWS(socket, client) {\n    client.setSocket(socket); // Cleanup after a socket closes.\n\n    socket.on(\"close\", () => {\n      if (client.getSocket() === socket) {\n        this.realm.removeClientById(client.getId());\n        this.emit(\"close\", client);\n      }\n    }); // Handle messages from peers.\n\n    socket.on(\"message\", data => {\n      try {\n        const message = JSON.parse(data);\n        message.src = client.getId();\n        this.emit(\"message\", client, message);\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    });\n    this.emit(\"connection\", client);\n  }\n\n  _sendErrorAndClose(socket, msg) {\n    socket.send(JSON.stringify({\n      type: enums_1.MessageType.ERROR,\n      payload: {\n        msg\n      }\n    }));\n    socket.close();\n  }\n\n}\n\nexports.WebSocketServer = WebSocketServer;","map":{"version":3,"sources":["/usr/local/lib/node_modules/peer/dist/src/services/webSocketServer/index.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WebSocketServer","events_1","require","url_1","ws_1","enums_1","client_1","WS_PATH","default","constructor","server","realm","config","setMaxListeners","path","endsWith","socketServer","Server","on","socket","req","_onSocketConnection","error","_onSocketError","_a","query","parse","url","id","token","key","_sendErrorAndClose","Errors","INVALID_WS_PARAMETERS","INVALID_KEY","client","getClientById","getToken","send","JSON","stringify","type","MessageType","ID_TAKEN","payload","msg","close","_configureWS","_registerClient","emit","clientsCount","getClientsIds","length","concurrent_limit","CONNECTION_LIMIT_EXCEED","newClient","Client","setClient","OPEN","setSocket","getSocket","removeClientById","getId","data","message","src","e","ERROR"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebSocketServer = void 0;\nconst events_1 = __importDefault(require(\"events\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst ws_1 = __importDefault(require(\"ws\"));\nconst enums_1 = require(\"../../enums\");\nconst client_1 = require(\"../../models/client\");\nconst WS_PATH = 'peerjs';\nclass WebSocketServer extends events_1.default {\n    constructor({ server, realm, config }) {\n        super();\n        this.setMaxListeners(0);\n        this.realm = realm;\n        this.config = config;\n        const path = this.config.path;\n        this.path = `${path}${path.endsWith('/') ? \"\" : \"/\"}${WS_PATH}`;\n        this.socketServer = new ws_1.default.Server({ path: this.path, server });\n        this.socketServer.on(\"connection\", (socket, req) => this._onSocketConnection(socket, req));\n        this.socketServer.on(\"error\", (error) => this._onSocketError(error));\n    }\n    _onSocketConnection(socket, req) {\n        var _a;\n        const { query = {} } = url_1.default.parse((_a = req.url) !== null && _a !== void 0 ? _a : '', true);\n        const { id, token, key } = query;\n        if (!id || !token || !key) {\n            return this._sendErrorAndClose(socket, enums_1.Errors.INVALID_WS_PARAMETERS);\n        }\n        if (key !== this.config.key) {\n            return this._sendErrorAndClose(socket, enums_1.Errors.INVALID_KEY);\n        }\n        const client = this.realm.getClientById(id);\n        if (client) {\n            if (token !== client.getToken()) {\n                // ID-taken, invalid token\n                socket.send(JSON.stringify({\n                    type: enums_1.MessageType.ID_TAKEN,\n                    payload: { msg: \"ID is taken\" }\n                }));\n                return socket.close();\n            }\n            return this._configureWS(socket, client);\n        }\n        this._registerClient({ socket, id, token });\n    }\n    _onSocketError(error) {\n        // handle error\n        this.emit(\"error\", error);\n    }\n    _registerClient({ socket, id, token }) {\n        // Check concurrent limit\n        const clientsCount = this.realm.getClientsIds().length;\n        if (clientsCount >= this.config.concurrent_limit) {\n            return this._sendErrorAndClose(socket, enums_1.Errors.CONNECTION_LIMIT_EXCEED);\n        }\n        const newClient = new client_1.Client({ id, token });\n        this.realm.setClient(newClient, id);\n        socket.send(JSON.stringify({ type: enums_1.MessageType.OPEN }));\n        this._configureWS(socket, newClient);\n    }\n    _configureWS(socket, client) {\n        client.setSocket(socket);\n        // Cleanup after a socket closes.\n        socket.on(\"close\", () => {\n            if (client.getSocket() === socket) {\n                this.realm.removeClientById(client.getId());\n                this.emit(\"close\", client);\n            }\n        });\n        // Handle messages from peers.\n        socket.on(\"message\", (data) => {\n            try {\n                const message = JSON.parse(data);\n                message.src = client.getId();\n                this.emit(\"message\", client, message);\n            }\n            catch (e) {\n                this.emit(\"error\", e);\n            }\n        });\n        this.emit(\"connection\", client);\n    }\n    _sendErrorAndClose(socket, msg) {\n        socket.send(JSON.stringify({\n            type: enums_1.MessageType.ERROR,\n            payload: { msg }\n        }));\n        socket.close();\n    }\n}\nexports.WebSocketServer = WebSocketServer;\n"]},"metadata":{},"sourceType":"script"}